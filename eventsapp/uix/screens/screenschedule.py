'''Screen Schedule
'''

from kivy.app import App
from kivy.uix.screenmanager import Screen
from kivy.lang import Builder
from kivy.factory import Factory
import datetime
from kivy.properties import ObjectProperty, ListProperty
from uix.tabbedcarousel import TabbedCarousel

app = App.get_running_app()


class TalkInfo(
        Factory.TouchRippleBehavior,
        Factory.ButtonBehavior, Factory.BoxLayout):
    '''
    '''

    talk = ObjectProperty(None)
    color = ListProperty((.5, .5, .5, .7))

    Builder.load_string('''
<TalkInfo>
    canvas.before:
        Color:
            rgba: app.base_inactive_color[:3]+ [.3]
        Rectangle:
            size: self.width + dp(10), self.height
            pos: self.x - dp(5), self.y
    size_hint_y: None
    height: max(lblinfo.texture_size[1] + dp(24), dp(40))
    spacing: dp(9)
    on_release:
        from utils import load_screen
        scr = load_screen('ScreenTalks', manager=app.navigation_manager)
        scr.talkid = self.talk['talk_id']
    LeftAlignedLabel:
        size_hint: None, 1
        valign: 'middle'
        width: dp(45)
        color: .09, .09, .09, 1
        text: "{}\\n{}".format(root.talk['start_time'], root.talk['end_time'])
    Label:
        id: lblinfo
        valign: 'middle'
        size_hint: 1, 1
        color: .09, .09, .09, 1
        text_size: self.width, None
        text: root.talk['title']
''')


class ScreenSchedule(Screen):
    '''
    Screen to display the schedule as per schedule.json generated by
    pyconf.network every time the app is started. A default
    schedule is provided.
    '''

    Builder.load_string('''

<Header@LeftAlignedLabel>
    size_hint_y: None
    height: dp(27)
    width: dp(40)
    size_hint: None, 1
    #background_color: app.base_active_color[:3] + [.3]
    canvas.before:
        Color
            rgba: root.background_color\
            if root.background_color else (1, 1, 1, 1)
        Rectangle
            size: self.size
            pos: self.pos

<ScreenSchedule>
    name: 'ScreenSchedule'
    BoxLayout
        # spacing: dp(20)
        canvas.before:
            Color:
                rgba: app.base_active_color
            Rectangle:
                size: self.width, dp(45)
                pos: self.x, self.top - dp(45)
        orientation: 'vertical'
        padding: dp(4)
        TabbedPanel
            id: accordian_days
            canvas.before:
                Color
                    rgba: app.base_inactive_light
                Rectangle:
                    size: self.width + dp(12), dp(54)
                    pos: -dp(4), -dp(4)

            background_color: 1, 1, 1, 0
            do_default_tab: False
            orientation: 'vertical'
            tab_width: self.width/5
            tab_pos: 'top_left'

<TalkTitle@BoxLayout>
    spacing: dp(9)
    height: dp(30)
    size_hint_y: None
    Header
        size_hint: None,None
        text: 'Time'
    Header
        text: 'Title'

<TabbedCarousel>
    tab_pos: 'bottom_left'
    tab_width: self.width/3
    background_color: 0, 0, 0, 0

<TabbedPanelHeader>
    background_color: (1, 1, 1, 1) if self.state == 'down' else (0, 0, 0, 0)
    background_normal: 'atlas://data/default/but_overlay'
    background_down: 'atlas://data/default/but_overlay'

<Track@Screen>
    ScrollView
        ScrollGrid
            id: container
 ''')

    def on_pre_enter(self):
        container = self.ids.accordian_days
        container.opacity = 0

    def on_enter(self, onsuccess=False):
        '''Series of actions to be performed when Schedule screen is entered
        '''
        container = self.ids.accordian_days
        # make sure the corresponding navigation is depressed
        app.navigationscreen.ids.left_panel.ids.bt_sched.state = 'down'
        # if the screen loads by pressing back, do nothing.
        if self.from_back is True:
            Factory.Animation(d=.5, opacity=1).start(container)
            return
        self.ids.accordian_days.clear_tabs()
        from network import get_data

        events = get_data('event', onsuccess=onsuccess)
        if not events:
            return

        schedule = get_data('schedule', onsuccess=onsuccess)
        if not schedule:
            return

        events = events.get('0.0.1')
        schedule = schedule.get('0.0.1')[0]

        # take first event as the one to display schedule for.
        self.event = event = events[0]
        app.event_name = event['name']
        app.venue_name = event['venue']
        # start_date = event['start_date']
        # end_date = event['end_date']

        dates = list(schedule.keys())
        dates.remove('tracks')
        # each day could have multiple tracks
        tracks = schedule['tracks']
        dates = sorted(
            dates,
            key=lambda x: datetime.datetime.strptime(x, '%Y-%m-%d'))

        # perf optims, minimize dot lookups
        acordion_add = self.ids.accordian_days.add_widget
        TI = Factory.TabbedPanelItem
        Track = Factory.Track

        first = None
        today = datetime.datetime.now()
        strt = datetime.datetime.strptime
        for date in dates:
            # add current day as accordion widget
            ccday = strt(date, "%Y-%m-%d")
            cday = TI(text=ccday.strftime("%d %b"))

            if not first:
                first = cday
            acordion_add(cday)
            day_sched = schedule[date]
            # create a carousel for each track
            tcarousel = TabbedCarousel()
            ti = TalkInfo

            # this carousel would show each track as new tab
            trackscreens = []
            tsa = trackscreens.append
            tca = tcarousel.add_widget
            for track in tracks:
                new_trk = Track(name=track,)
                tsa(new_trk)
                # add track to carousel
                tca(new_trk)

            for talk in day_sched:
                # try:
                #     stime = "%s -- %s" % (date, talk['start_time'])
                #     etime = "%s -- %s" % (date, talk['end_time'])
                #     stime = strt(stime, "%Y-%m-%d -- %H:%M")
                #     etime = strt(etime, "%Y-%m-%d -- %H:%M")
                #     talk['current'] = today > stime and today < etime
                # except:
                #     pass
                tid = talk['track']
                if tid.lower() == 'all':
                    for tlk in trackscreens:
                        ti = TalkInfo(talk=talk)
                        tlk.ids.container.add_widget(ti)
                    continue
                ti = TalkInfo(talk=talk)
                try:
                    trackscreens[int(tid)-1].ids.container.add_widget(ti)
                except IndexError:
                    pass

            cday.add_widget(tcarousel)
            if (ccday.day, ccday.month, ccday.year) ==\
               (today.day, today.month, today.year):
                first = cday
        if first:
            first.trigger_action()
            first = False
        Factory.Animation(d=.5, opacity=1).start(container)
